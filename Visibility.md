```java
synchronized(this) { 
	executionCount++; someTask(); 
}
```

^7a5e33

然而，还有一件事情是简单的。记住，前面的例子[[#^7a5e33]]是一个抽象！它是用计算机语言——比如Java——写的，因此，与硬件的实际行为只有编译器编写者、JVM开发者和硬件架构师的恩典有关。
这两个Java语句会被翻译成数百条微指令，其中许多是并行执行的，在数十个硬件时钟周期内完成。这种有序发生的错觉不过是一个幻觉。

维持幻觉并不是靠近底层开发人员自然而然会做的事情。相反，他们认为顺序程序天真、笨拙且浪费。他们很乐意通过重新排列指令、并行执行多个指令、将程序状态的单个部分表示为多个副本等方式来修复它们。通过这样做，他们尽最大努力充分利用组成我们口袋中甚至微小设备的多处理器的巨大能力。
总的来说，我们很高兴让他们执行这些优化。它们使我们的程序在多个硬件平台上运行更快，使用应用程序开发人员并不那么感兴趣的技巧。然而，这种优化有一个重要条件：它们不能破坏顺序性的幻觉！**换句话说，编译器和硬件流水线可以重新排序和并行化所有内容以优化代码，只要开发人员无法察觉到他们这样做了。**
在使程序并发时，开发人员明确表示不同线程控制的状态之间没有顺序依赖关系。如果没有顺序依赖关系，编译器应该可以自由执行各种优化，否则可能会不安全。在不同线程中的事件之间没有明确的顺序排列时，编译器可以自由更改一个线程的执行顺序，而不考虑其他任何语句。

一个正确的并发程序是遵守维持幻觉的契约的程序。应用程序员和硬件开发人员之间的协商产生了一种语言，而这种语言就是一种契约。

应用程序开发人员得到了他们对于顺序执行的幻觉，这是他们可以进行推理的内容。硬件开发人员得到了一套聪明的技巧工具箱，可以用来加快程序运行速度。

契约就在中间。在Java中，这个契约被称为内存模型。

契约的一边是应用程序员，用高级语言推理她的程序。契约的另一边是编译器编写人员、虚拟机开发人员和硬件架构师，移动一切未被明确禁止的内容。

讨论并发的开发者要是讨论硬件就没有谈到点（Developers who talk about hardware when discussing concurrency are missing the point.）。一个正确的并发程序不是关于硬件；它是关于开发人员遵守他们的契约。

幸运的是，在Java中，这个契约很容易陈述。

以下一句几乎完全陈述了它：每当多个线程访问给定状态变量，并且其中一个可能对其进行写入时，它们都必须使用同步来协调对其的访问。

一个正确的并发Java程序就是遵守这个契约的程序——不多，也不少。特别要注意的是，一个线程是读取还是写入可变状态并不会以任何方式影响它对同步的需求。