在开发者的环境中，时间和顺序是严格和隐含的约束条件，“并发”只是“顺序未指定”的另一个说法——就像其他地方一样。

一个并发程序只是向一个已经并发的世界宣告，它的正确性不依赖于发生在不同组件中事件的顺序。

在一个并发程序中，这些分离的、部分有序的组件被称为执行线程，或者简称为线程[[Threads]]。在一个线程内部，指令仍然按严格的顺序执行。然而，在两个不同线程中指令的执行顺序是完全未指定的。

在计算机发展的早期阶段，将线程作为并发模型的选择并不明显。那些需要乱序处理的开发人员不得不自行设计并发构造。上世纪六十年代的文献和代码中包含了各种各样的异步执行模型。

线程可能起源于20世纪60年代末的IBM OS/360。它们被称为“任务”，是一个操作系统级别的服务，可以帮助开发人员避免构建自己的并发抽象。1991年，当时被称为Oak的Java采用了线程模型，并在语言中支持它，即使在不支持的操作系统上也是如此。即使在今天，线程也不是唯一的并发模型。例如，诸如Erlang、Go和Clojure等语言，每种都采用完全不同的模型。

将线程引入编程模型并不会带来固有问题。同时操作两辆车并行行驶并不会有问题，除非它们同时试图占据同一空间。同样，操作两个完全独立的线程也是完全安全的。此刻，有数百万个程序在数百万台独立的计算机上并发运行，它们各自在自己的执行线程中运行。其中大多数程序彼此之间没有任何交互，并且它们的行为是完全明确定义的。**问题只会在线程需要共享状态和资源时出现。**


